# Beads Workflow Module

**Distributed, git-backed graph issue tracker for AI agents.**

## Overview

Beads provides persistent, structured memory for coding agents. It replaces messy markdown plans with a dependency-aware graph, allowing agents to handle long-horizon tasks without losing context.

## Key Benefits

- **Git as Database**: Issues stored as JSONL in `.beads/` directory, versioned with your code
- **Agent-Optimized**: JSON output, dependency tracking, auto-ready task detection
- **Zero Conflict**: Hash-based IDs (`bd-a1b2`) prevent merge collisions in multi-agent workflows
- **Invisible Infrastructure**: SQLite local cache for speed, background daemon for auto-sync
- **Memory Decay**: Semantic compaction summarizes old closed tasks to save context window

## Installation Options

### Option 1: With CLI (Recommended)

Install the Beads CLI for full features:

```bash
# npm
npm install -g @beads/bd

# Homebrew
brew install steveyegge/beads/bd

# Go
go install github.com/steveyegge/beads/cmd/bd@latest

# Initialize in your project
cd your-project
bd init
```

**Benefits**: SQLite cache, auto-sync daemon, validation, JSON output, compaction

### Option 2: Without CLI (Manual)

Work with `.beads/` files directly without installing the CLI. See `rules/manual-setup.md` for instructions.

**Benefits**: No installation required, works immediately

**Limitations**: No SQLite cache, manual sync, no validation, no compaction

## Directory Structure

```
your-project/
├── .beads/
│   ├── issues.jsonl          # All issues (append-only log)
│   ├── config.json           # Beads configuration
│   └── cache.db              # SQLite cache (CLI only, gitignored)
└── AGENTS.md                 # AI agent instructions
```

## Core Workflow

### Creating Tasks

```bash
# With CLI
bd create "Implement user authentication" -p 0

# Without CLI - append to .beads/issues.jsonl
```

### Viewing Ready Tasks

```bash
# With CLI
bd ready

# Shows tasks with no open blockers
```

### Managing Dependencies

```bash
# With CLI
bd dep add <child-id> <parent-id>

# Creates blocks/blocked-by relationships
```

### Closing Tasks

```bash
# With CLI
bd close <id>

# Marks task as closed
```

## Hierarchical IDs

Beads supports epic/task/subtask hierarchy:

- `bd-a3f8` (Epic)
- `bd-a3f8.1` (Task)
- `bd-a3f8.1.1` (Sub-task)

## Stealth Mode

Use Beads locally without committing to the main repo:

```bash
bd init --stealth
```

Perfect for personal use on shared projects.

## Character Count

This module contains comprehensive Beads workflow documentation that exceeds the standard `.augment/` folder character limit.

**Total**: ~28,000 characters across all rule files

## Contents

- `rules/workflow.md` - Complete workflow guide
- `rules/file-format.md` - JSONL file format specification
- `rules/manual-setup.md` - Manual setup without CLI
- `rules/commands.md` - CLI command reference
- `rules/best-practices.md` - Tips and patterns
- `examples/` - Example workflows and use cases

## Learn More

- **GitHub**: https://github.com/steveyegge/beads
- **Agent Instructions**: https://github.com/steveyegge/beads/blob/main/AGENT_INSTRUCTIONS.md
- **Documentation**: See `rules/` directory in this module

# Beads Best Practices

## Task Creation

### Use Descriptive Titles

✅ **Good**: Clear, actionable titles
- "Implement JWT authentication"
- "Fix login timeout bug"
- "Refactor database connection pool"

❌ **Bad**: Vague or cryptic titles
- "Fix bug"
- "Update code"
- "Task 123"

### Set Appropriate Priorities

- **P0** - Critical, blocking production
- **P1** - High priority, needed soon
- **P2** - Medium priority (default)
- **P3** - Nice to have, low priority

### Add Descriptions

Include context in the description field:

```json
{
  "id": "bd-a1b2",
  "title": "Implement JWT authentication",
  "description": "Add JWT-based authentication with email/password login. Use bcrypt for password hashing. Tokens expire after 24 hours.",
  "priority": 0
}
```

## Dependency Management

### Model Real Dependencies

Only use `blocks`/`blocked_by` for actual dependencies:

✅ **Good**: Real blocking relationships
```
bd-a1b2: "Add database schema"
  blocks: ["bd-b2c3", "bd-c3d4"]

bd-b2c3: "Add API endpoint"
  blocked_by: ["bd-a1b2"]
```

❌ **Bad**: Artificial dependencies
```
bd-a1b2: "Write documentation"
  blocks: ["bd-b2c3"]  # Doesn't actually block implementation
```

### Use Related for Loose Coupling

Use `related` for tasks that should be aware of each other but don't block:

```json
{
  "id": "bd-c3d4",
  "title": "Add frontend login form",
  "related": ["bd-b2c3"]  # Related to backend endpoint
}
```

### Break Circular Dependencies

Avoid circular dependencies:

❌ **Bad**:
```
bd-a1b2 blocks bd-b2c3
bd-b2c3 blocks bd-a1b2  # Circular!
```

✅ **Good**: Break into smaller tasks
```
bd-a1b2: "Add database schema"
bd-b2c3: "Add API endpoint" (blocked_by: bd-a1b2)
bd-c3d4: "Add validation" (blocked_by: bd-b2c3)
```

## Hierarchical Tasks

### Use for Epics

Create hierarchical IDs for large features:

```
bd-a3f8: "User Management System" (Epic)
  ├─ bd-a3f8.1: "Add authentication"
  │   ├─ bd-a3f8.1.1: "Hash passwords"
  │   └─ bd-a3f8.1.2: "Generate JWT tokens"
  └─ bd-a3f8.2: "Add user profiles"
      ├─ bd-a3f8.2.1: "Create profile model"
      └─ bd-a3f8.2.2: "Add profile API"
```

### Keep Hierarchy Shallow

Limit to 3 levels:
- Level 1: Epic
- Level 2: Task
- Level 3: Subtask

Deeper hierarchies become hard to manage.

## Status Management

### Update Status Promptly

Keep status current:

```
open → in-progress → closed
```

### Use Blocked Status

Mark tasks as blocked when waiting:

```json
{
  "id": "bd-b2c3",
  "status": "blocked",
  "blocked_by": ["bd-a1b2"]
}
```

### Close Completed Tasks

Always close tasks when done:

```json
{
  "id": "bd-a1b2",
  "status": "closed",
  "closed": "2024-01-20T12:00:00Z"
}
```

## Comments and Documentation

### Add Progress Comments

Document progress and decisions:

```json
{
  "id": "bd-a1b2",
  "comments": [
    {
      "text": "Started implementation, using bcrypt for hashing",
      "timestamp": "2024-01-20T11:00:00Z"
    },
    {
      "text": "Completed password hashing, moving to JWT generation",
      "timestamp": "2024-01-20T12:00:00Z"
    }
  ]
}
```

### Document Blockers

Explain why tasks are blocked:

```json
{
  "id": "bd-b2c3",
  "status": "blocked",
  "blocked_by": ["bd-a1b2"],
  "comments": [
    {
      "text": "Waiting for database schema to be finalized",
      "timestamp": "2024-01-20T10:00:00Z"
    }
  ]
}
```

## Labels and Organization

### Use Consistent Labels

Establish label conventions:

- **Component**: `backend`, `frontend`, `database`, `api`
- **Type**: `bug`, `feature`, `refactor`, `docs`
- **Area**: `auth`, `users`, `payments`, `search`

```json
{
  "id": "bd-a1b2",
  "title": "Implement JWT authentication",
  "labels": ["backend", "feature", "auth"]
}
```

### Filter by Labels

Use labels to find related tasks:

```bash
# With CLI
bd list --labels auth

# Without CLI - parse and filter
```

## Multi-Agent Workflows

### Use Assignees

Track who is working on what:

```json
{
  "id": "bd-a1b2",
  "title": "Add authentication",
  "assignee": "agent-1",
  "status": "in-progress"
}
```

### Avoid Conflicts

Use hash-based IDs to prevent merge conflicts:

✅ **Good**: Hash-based IDs
```
bd-a1b2
bd-b2c3
```

❌ **Bad**: Sequential IDs
```
task-1
task-2  # Conflicts in parallel branches
```

### Sync Regularly

With CLI, the daemon auto-syncs. Without CLI, commit and pull regularly:

```bash
git add .beads/issues.jsonl
git commit -m "Update tasks"
git pull --rebase
git push
```

## Performance

### Use CLI for Large Projects

For projects with >100 tasks, use the CLI:
- SQLite cache provides fast queries
- Auto-sync daemon keeps data current
- Compaction reduces context window usage

### Compact Regularly

Run compaction to summarize old tasks:

```bash
bd compact
```

This creates semantic summaries of closed tasks, reducing file size.

### Archive Old Tasks

Move very old closed tasks to archive:

```bash
# With CLI
bd archive --older-than 90d

# Without CLI - manually move to separate file
```

## Git Integration

### Commit Task Updates

Commit `.beads/issues.jsonl` with related code:

```bash
git add .beads/issues.jsonl src/auth.py
git commit -m "Implement JWT authentication (bd-a1b2)"
```

### Reference in Commits

Reference task IDs in commit messages:

```
Implement JWT authentication (bd-a1b2)

- Add JWT generation
- Add password hashing with bcrypt
- Add login endpoint
```

### Branch Naming

Include task ID in branch names:

```bash
git checkout -b bd-a1b2-add-authentication
```

## Stealth Mode

### Personal Use on Shared Projects

Use stealth mode for personal task tracking:

```bash
bd init --stealth
```

This creates `.beads/` in a separate branch that doesn't merge to main.

### Team Adoption

When team is ready, disable stealth:

```bash
bd config set stealth false
git add .beads/
git commit -m "Enable Beads for team"
```

## Common Pitfalls

### ❌ Forgetting to Update Status

Don't leave tasks in "open" when you're working on them.

### ❌ Creating Too Many Dependencies

Only model real blocking relationships.

### ❌ Vague Titles

Be specific about what needs to be done.

### ❌ Not Closing Tasks

Always close completed tasks to keep the list clean.

### ❌ Ignoring Ready Tasks

Use `bd ready` to find tasks you can work on now.

## AI Agent Collaboration

### Provide Context

When asking AI to create tasks:

```
Create a Beads task for implementing user authentication.
Priority: 0
Description: Add JWT-based auth with email/password login
Labels: backend, feature, auth
```

### Check Ready Tasks

Ask AI to check what's ready:

```
What Beads tasks are ready to work on right now?
```

### Update Progress

Ask AI to document progress:

```
Add a comment to bd-a1b2: "Completed password hashing, starting JWT generation"
```

### Close When Done

Ask AI to close completed tasks:

```
Close Beads task bd-a1b2, we've finished the implementation
```

# Beads File Format Specification

## Overview

Beads stores issues in `.beads/issues.jsonl` using JSONL (JSON Lines) format. Each line is a complete JSON object representing an issue or update.

## JSONL Format

**JSONL** = One JSON object per line, newline-separated.

```jsonl
{"id":"bd-a1b2","title":"Task 1","status":"open"}
{"id":"bd-b2c3","title":"Task 2","status":"closed"}
{"id":"bd-c3d4","title":"Task 3","status":"open"}
```

## Issue Schema

### Minimal Issue

```json
{
  "id": "bd-a1b2",
  "title": "Implement user authentication",
  "status": "open",
  "created": "2024-01-20T10:00:00Z",
  "updated": "2024-01-20T10:00:00Z"
}
```

### Complete Issue

```json
{
  "id": "bd-a1b2",
  "title": "Implement user authentication",
  "description": "Add JWT-based authentication with email/password login",
  "status": "open",
  "priority": 0,
  "labels": ["backend", "auth", "security"],
  "assignee": "agent-1",
  "blocks": ["bd-b2c3", "bd-c3d4"],
  "blocked_by": [],
  "related": ["bd-d4e5"],
  "parent": null,
  "spec": "features/authentication",
  "rules": ["module-development.md", "security-guidelines.md"],
  "comments": [
    {
      "text": "Started implementation",
      "author": "agent-1",
      "timestamp": "2024-01-20T11:00:00Z"
    }
  ],
  "created": "2024-01-20T10:00:00Z",
  "updated": "2024-01-20T11:00:00Z",
  "closed": null
}
```

## Field Definitions

### Required Fields

- **id** (string): Unique hash-based ID, format: `bd-<hash>` or `bd-<hash>.<number>` for hierarchical
- **title** (string): Short description of the task
- **status** (string): One of: `"open"`, `"in-progress"`, `"blocked"`, `"closed"`
- **created** (string): ISO 8601 timestamp
- **updated** (string): ISO 8601 timestamp

### Optional Fields

- **description** (string): Detailed description
- **priority** (integer): 0 (highest) to 3 (lowest), default: 2
- **labels** (array of strings): Tags for categorization
- **assignee** (string): Who is working on this
- **blocks** (array of strings): IDs of tasks this task blocks
- **blocked_by** (array of strings): IDs of tasks blocking this task
- **related** (array of strings): IDs of related tasks
- **parent** (string): ID of parent task (for hierarchical IDs)
- **comments** (array of objects): Comments and updates
- **closed** (string): ISO 8601 timestamp when closed
- **spec** (string): OpenSpec specification ID this task implements (e.g., "features/authentication")
- **rules** (array of strings): `.augment/` rule files that apply to this task (e.g., ["module-development.md"])

## ID Format

### Standard IDs

Hash-based, 4-character hex:

```
bd-a1b2
bd-b2c3
bd-c3d4
```

### Hierarchical IDs

Epic/task/subtask structure:

```
bd-a3f8        # Epic
bd-a3f8.1      # Task under epic
bd-a3f8.1.1    # Subtask
bd-a3f8.2      # Another task under epic
```

## Status Values

- **open** - Task is ready to work on (no blockers)
- **in-progress** - Currently being worked on
- **blocked** - Waiting on dependencies
- **closed** - Completed or cancelled

## Priority Values

- **0** - Critical (P0)
- **1** - High (P1)
- **2** - Medium (P2) - default
- **3** - Low (P3)

## Coordination Fields

### spec

References an OpenSpec specification that this task implements:

```json
{
  "id": "bd-a1b2",
  "title": "Add authentication API",
  "spec": "features/authentication"
}
```

The `spec` field links the task to an OpenSpec specification file (e.g., `openspec/specs/features/authentication.md`). This enables:
- Automatic traceability from spec to implementation
- Discovery of all tasks implementing a spec
- Coordination manifest integration

### rules

Lists `.augment/` rule files that apply to this task:

```json
{
  "id": "bd-a1b2",
  "title": "Add authentication API",
  "rules": ["module-development.md", "security-guidelines.md"]
}
```

The `rules` field helps AI agents:
- Load relevant coding standards and guidelines
- Apply appropriate validation rules
- Maintain consistency across tasks

**Note**: These fields are optional and backward compatible. Existing tasks without these fields continue to work normally.

---

## Dependency Types

### blocks

Tasks that this task prevents from starting:

```json
{
  "id": "bd-a1b2",
  "title": "Add database schema",
  "blocks": ["bd-b2c3", "bd-c3d4"]
}
```

Means: `bd-b2c3` and `bd-c3d4` cannot start until `bd-a1b2` is closed.

### blocked_by

Tasks that must be completed before this task can start:

```json
{
  "id": "bd-b2c3",
  "title": "Add API endpoint",
  "blocked_by": ["bd-a1b2"]
}
```

Means: `bd-b2c3` cannot start until `bd-a1b2` is closed.

### related

Tasks that are related but not blocking:

```json
{
  "id": "bd-c3d4",
  "title": "Add frontend form",
  "related": ["bd-b2c3"]
}
```

## Comments Format

```json
{
  "comments": [
    {
      "text": "Started implementation",
      "author": "agent-1",
      "timestamp": "2024-01-20T11:00:00Z"
    },
    {
      "text": "Added login endpoint",
      "author": "agent-1",
      "timestamp": "2024-01-20T12:00:00Z"
    }
  ]
}
```

## Append-Only Log

`.beads/issues.jsonl` is an **append-only log**. Updates are appended as new lines:

```jsonl
{"id":"bd-a1b2","title":"Task 1","status":"open","created":"2024-01-20T10:00:00Z","updated":"2024-01-20T10:00:00Z"}
{"id":"bd-a1b2","status":"in-progress","updated":"2024-01-20T11:00:00Z"}
{"id":"bd-a1b2","status":"closed","closed":"2024-01-20T12:00:00Z","updated":"2024-01-20T12:00:00Z"}
```

The **latest entry** for each ID is the current state.

## Reading Issues

### With CLI

The CLI maintains a SQLite cache (`.beads/cache.db`) for fast queries:

```bash
bd list        # Query cache
bd ready       # Query cache
bd show bd-a1b2  # Query cache
```

### Without CLI

Parse `.beads/issues.jsonl` manually:

1. Read all lines
2. Parse each line as JSON
3. Group by `id`
4. Merge fields (latest wins)
5. Return current state

## Writing Issues

### With CLI

```bash
bd create "Title" -p 0
# Appends to issues.jsonl and updates cache
```

### Without CLI

Append JSON line to `.beads/issues.jsonl`:

```bash
echo '{"id":"bd-a1b2","title":"New task","status":"open","created":"2024-01-20T10:00:00Z","updated":"2024-01-20T10:00:00Z"}' >> .beads/issues.jsonl
```

## Configuration File

`.beads/config.json`:

```json
{
  "version": "1.0",
  "stealth": false,
  "compact_threshold": 100,
  "auto_sync": true
}
```

## Best Practices

1. **Always append**: Never edit existing lines
2. **Include timestamps**: Use ISO 8601 format
3. **Unique IDs**: Use hash-based IDs to avoid conflicts
4. **Atomic updates**: One field change per line
5. **Validate JSON**: Ensure each line is valid JSON

## Example Workflow

### Create Task

```jsonl
{"id":"bd-a1b2","title":"Add authentication","status":"open","priority":0,"spec":"features/authentication","rules":["module-development.md"],"created":"2024-01-20T10:00:00Z","updated":"2024-01-20T10:00:00Z"}
```

### Add Dependency

```jsonl
{"id":"bd-a1b2","blocks":["bd-b2c3"],"updated":"2024-01-20T10:05:00Z"}
```

### Start Work

```jsonl
{"id":"bd-a1b2","status":"in-progress","updated":"2024-01-20T11:00:00Z"}
```

### Add Comment

```jsonl
{"id":"bd-a1b2","comments":[{"text":"Added login endpoint","timestamp":"2024-01-20T12:00:00Z"}],"updated":"2024-01-20T12:00:00Z"}
```

### Close Task

```jsonl
{"id":"bd-a1b2","status":"closed","closed":"2024-01-20T13:00:00Z","updated":"2024-01-20T13:00:00Z"}
```

# Beads Manual Setup (Without CLI)

## Overview

You can use Beads without installing the CLI by working directly with `.beads/issues.jsonl` files. This guide shows how to set up and use Beads manually.

## Initial Setup

### 1. Create Directory Structure

```bash
mkdir .beads
touch .beads/issues.jsonl
```

### 2. Create Configuration File

Create `.beads/config.json`:

```json
{
  "version": "1.0",
  "stealth": false,
  "compact_threshold": 100,
  "auto_sync": true
}
```

### 3. Add to .gitignore

Add to `.gitignore`:

```
.beads/cache.db
.beads/cache.db-*
```

**Note**: Commit `.beads/issues.jsonl` and `.beads/config.json`, but not the cache.

### 4. Create AGENTS.md Integration

Add to your project's `AGENTS.md` (or create it):

```markdown
# Beads Task Tracking

This project uses Beads for task tracking. Issues are stored in `.beads/issues.jsonl`.

## File Format

Each line in `.beads/issues.jsonl` is a JSON object representing an issue or update.

### Creating Tasks

Append a JSON line:

```json
{"id":"bd-<hash>","title":"Task title","status":"open","priority":0,"created":"<ISO-8601>","updated":"<ISO-8601>"}
```

### Updating Tasks

Append a JSON line with the same ID and updated fields:

```json
{"id":"bd-<hash>","status":"in-progress","updated":"<ISO-8601>"}
```

### Closing Tasks

Append a JSON line with status "closed":

```json
{"id":"bd-<hash>","status":"closed","closed":"<ISO-8601>","updated":"<ISO-8601>"}
```

## Task States

- **open** - Ready to work on
- **in-progress** - Currently being worked on
- **blocked** - Waiting on dependencies
- **closed** - Completed

## Dependencies

Use `blocks` and `blocked_by` fields:

```json
{"id":"bd-a1b2","blocks":["bd-b2c3"],"updated":"<ISO-8601>"}
```

## Finding Ready Tasks

Tasks are ready when:
- Status is "open"
- `blocked_by` is empty or all blockers are closed

## Workflow

1. Create task by appending to `.beads/issues.jsonl`
2. Add dependencies with `blocks`/`blocked_by` fields
3. Find ready tasks (no open blockers)
4. Update status to "in-progress"
5. Add comments as needed
6. Close task when complete
```

## Generating Hash-Based IDs

### Simple Method

Use the first 4 characters of a hash:

```bash
# Linux/macOS
echo -n "$(date +%s%N)" | md5sum | cut -c1-4

# Or use a random string
echo -n "task-$(date +%s)" | md5sum | cut -c1-4
```

### In Code (Python)

```python
import hashlib
import time

def generate_id():
    hash_input = f"task-{time.time()}"
    hash_hex = hashlib.md5(hash_input.encode()).hexdigest()
    return f"bd-{hash_hex[:4]}"

print(generate_id())  # bd-a1b2
```

### In Code (JavaScript)

```javascript
const crypto = require('crypto');

function generateId() {
  const hashInput = `task-${Date.now()}`;
  const hash = crypto.createHash('md5').update(hashInput).digest('hex');
  return `bd-${hash.substring(0, 4)}`;
}

console.log(generateId());  // bd-a1b2
```

## Creating Your First Task

### 1. Generate ID

```bash
# Generate a unique ID
ID="bd-$(echo -n "task-$(date +%s)" | md5sum | cut -c1-4)"
echo $ID  # bd-a1b2
```

### 2. Create JSON

```bash
# Create task JSON
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
TASK=$(cat <<EOF
{"id":"$ID","title":"Implement user authentication","status":"open","priority":0,"created":"$TIMESTAMP","updated":"$TIMESTAMP"}
EOF
)
```

### 3. Append to File

```bash
echo "$TASK" >> .beads/issues.jsonl
```

## Working with AI Agents

### Creating Tasks

Ask your AI:

```
Create a Beads task for implementing user authentication with priority 0.
Append the JSON to .beads/issues.jsonl with a unique hash-based ID.
```

The AI will:
1. Generate a unique ID (e.g., `bd-a1b2`)
2. Create JSON with required fields
3. Append to `.beads/issues.jsonl`

### Finding Ready Tasks

Ask your AI:

```
What Beads tasks are ready to work on?
Parse .beads/issues.jsonl and find tasks where:
- status is "open"
- blocked_by is empty or all blockers are closed
```

### Updating Tasks

Ask your AI:

```
Update Beads task bd-a1b2 to status "in-progress"
Append an update to .beads/issues.jsonl
```

### Adding Dependencies

Ask your AI:

```
Make Beads task bd-b2c3 depend on bd-a1b2
Append updates to .beads/issues.jsonl:
- bd-a1b2 blocks bd-b2c3
- bd-b2c3 is blocked_by bd-a1b2
```

## Reading Current State

### Parse JSONL (Python)

```python
import json

def read_issues(filepath='.beads/issues.jsonl'):
    issues = {}
    with open(filepath, 'r') as f:
        for line in f:
            issue = json.loads(line.strip())
            issue_id = issue['id']
            if issue_id not in issues:
                issues[issue_id] = {}
            issues[issue_id].update(issue)
    return issues

# Get all issues
all_issues = read_issues()

# Find ready tasks
ready_tasks = [
    issue for issue in all_issues.values()
    if issue.get('status') == 'open' and not issue.get('blocked_by')
]
```

### Parse JSONL (JavaScript)

```javascript
const fs = require('fs');

function readIssues(filepath = '.beads/issues.jsonl') {
  const issues = {};
  const lines = fs.readFileSync(filepath, 'utf-8').split('\n');
  
  for (const line of lines) {
    if (!line.trim()) continue;
    const issue = JSON.parse(line);
    const issueId = issue.id;
    if (!issues[issueId]) {
      issues[issueId] = {};
    }
    Object.assign(issues[issueId], issue);
  }
  
  return issues;
}

// Get all issues
const allIssues = readIssues();

// Find ready tasks
const readyTasks = Object.values(allIssues).filter(
  issue => issue.status === 'open' && (!issue.blocked_by || issue.blocked_by.length === 0)
);
```

## Limitations Without CLI

- ❌ No SQLite cache (slower queries)
- ❌ No auto-sync daemon
- ❌ No validation
- ❌ No compaction
- ❌ Manual ID generation
- ❌ Manual JSONL parsing

## Benefits Without CLI

- ✅ No installation required
- ✅ Works immediately
- ✅ Full control over data
- ✅ Simple git workflow
- ✅ Compatible with all AI agents

## Upgrading to CLI Later

If you decide to install the CLI later:

```bash
npm install -g @beads/bd
cd your-project
bd init
```

The CLI will:
- Detect existing `.beads/issues.jsonl`
- Build SQLite cache from existing data
- Start auto-sync daemon
- Continue working with your existing issues

# Beads Workflow Guide

## Overview

Beads provides a git-backed issue tracker optimized for AI agents. Issues are stored as JSONL (JSON Lines) in `.beads/issues.jsonl`, making them version-controlled, mergeable, and agent-readable.

## Naming Convention

All Beads issues in this project use the **"bd-" prefix**.

### Standard Format

- `bd-<hash>` - Standard hash-based ID (e.g., `bd-a1b2`)
- `bd-<name>` - Named ID for important tasks (e.g., `bd-init`, `bd-rename1`)
- `bd-<hash>.<number>` - Hierarchical ID (e.g., `bd-a1b2.1`)

### Why "bd"?

- **Brevity**: Short and memorable (2 characters)
- **Clarity**: Clearly identifies Beads issues
- **Consistency**: Single prefix across all issues
- **Git-Friendly**: Reduces commit message length

### Validation

All new issues are validated to ensure they use the "bd-" prefix. See `openspec/specs/beads/naming-convention.md` for complete specification.

## Core Workflow

```
┌─────────────────┐
│ Create Task     │
│ bd create       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Add Dependencies│
│ bd dep add      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Find Ready Tasks│
│ bd ready        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Work on Task    │
│ bd comment      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Close Task      │
│ bd close        │
└─────────────────┘
```

## Coordination with OpenSpec and .augment/

Beads tasks can reference OpenSpec specifications and `.augment/` rules for better coordination:

```bash
# Create task with spec and rules
bd create "Implement authentication" -p 1
# Then manually add spec and rules fields to .beads/issues.jsonl:
# {"id":"bd-xyz","spec":"features/authentication","rules":["security-guidelines.md"],"updated":"..."}
```

**Benefits**:
- **Traceability**: Link tasks to specifications
- **Context**: AI agents load relevant rules automatically
- **Coordination**: Integration with coordination manifest

See `.augment/rules/coordination-system.md` for details.

---

## Step 1: Initialize Beads

### With CLI

```bash
cd your-project
bd init
```

This creates:
- `.beads/issues.jsonl` - Issue storage
- `.beads/config.json` - Configuration
- Updates `AGENTS.md` with Beads instructions

### Without CLI

Create the directory structure manually:

```bash
mkdir .beads
touch .beads/issues.jsonl
echo '{"version": "1.0"}' > .beads/config.json
```

Add to `AGENTS.md`:

```markdown
# Beads Task Tracking

This project uses Beads for task tracking. Issues are stored in `.beads/issues.jsonl`.

## Workflow
1. Create tasks by appending to `.beads/issues.jsonl`
2. Use hash-based IDs: `bd-<hash>`
3. Track dependencies with `blocks` and `blocked_by` fields
4. Mark tasks closed with `status: "closed"`
```

## Step 2: Create Tasks

### With CLI

```bash
# Create a P0 task
bd create "Implement user authentication" -p 0

# Create with description
bd create "Add login endpoint" -p 1 -d "POST /api/auth/login with email/password"

# Create subtask
bd create "Add password hashing" -p 1 --parent bd-a3f8.1
```

### Without CLI

Append JSON to `.beads/issues.jsonl`:

```json
{"id":"bd-a1b2","title":"Implement user authentication","status":"open","priority":0,"created":"2024-01-20T10:00:00Z","updated":"2024-01-20T10:00:00Z"}
```

### AI Agent Pattern

Ask your AI:

```
Create a Beads task for implementing user authentication with priority 0
```

The AI will either:
- Run `bd create` if CLI is available
- Append to `.beads/issues.jsonl` if working manually

## Step 3: Add Dependencies

### With CLI

```bash
# Task bd-b2c3 blocks task bd-a1b2
bd dep add bd-a1b2 bd-b2c3

# View dependencies
bd show bd-a1b2
```

### Without CLI

Update the issue in `.beads/issues.jsonl`:

```json
{"id":"bd-a1b2","title":"Implement user authentication","status":"open","priority":0,"blocks":["bd-b2c3"],"created":"2024-01-20T10:00:00Z","updated":"2024-01-20T10:00:00Z"}
```

### Dependency Types

- **blocks** - This task blocks another task
- **blocked_by** - This task is blocked by another task
- **related** - Related but not blocking
- **parent** - Parent task (for hierarchical IDs)

## Step 4: Find Ready Tasks

### With CLI

```bash
# List tasks with no open blockers
bd ready

# List all open tasks
bd list

# Filter by priority
bd list -p 0
```

### Without CLI

Parse `.beads/issues.jsonl` to find tasks where:
- `status` is `"open"`
- `blocked_by` is empty or all blockers are closed

### AI Agent Pattern

Ask your AI:

```
What Beads tasks are ready to work on?
```

The AI will:
- Run `bd ready` if CLI available
- Parse `.beads/issues.jsonl` manually otherwise

## Step 5: Work on Task

### With CLI

```bash
# Add comment
bd comment bd-a1b2 "Started implementation, added login endpoint"

# Update status
bd update bd-a1b2 --status in-progress

# Add labels
bd update bd-a1b2 --labels backend,auth
```

### Without CLI

Append update to `.beads/issues.jsonl`:

```json
{"id":"bd-a1b2","title":"Implement user authentication","status":"in-progress","priority":0,"comments":[{"text":"Started implementation","timestamp":"2024-01-20T11:00:00Z"}],"updated":"2024-01-20T11:00:00Z"}
```

## Step 6: Close Task

### With CLI

```bash
bd close bd-a1b2
```

### Without CLI

Update status in `.beads/issues.jsonl`:

```json
{"id":"bd-a1b2","title":"Implement user authentication","status":"closed","priority":0,"closed":"2024-01-20T12:00:00Z","updated":"2024-01-20T12:00:00Z"}
```

## Essential Commands

### With CLI

| Command | Action |
|---------|--------|
| `bd create "Title" -p 0` | Create P0 task |
| `bd ready` | List tasks with no blockers |
| `bd list` | List all open tasks |
| `bd show <id>` | View task details |
| `bd dep add <child> <parent>` | Add dependency |
| `bd comment <id> "Text"` | Add comment |
| `bd close <id>` | Close task |
| `bd compact` | Summarize old closed tasks |

### Without CLI

All operations are manual edits to `.beads/issues.jsonl`. See `file-format.md` for JSONL structure.

## Advanced Features

### Hierarchical Tasks

Create epic/task/subtask structure:

```bash
# Create epic
bd create "User Management" -p 0
# Returns: bd-a3f8

# Create task under epic
bd create "Add authentication" -p 1 --parent bd-a3f8
# Returns: bd-a3f8.1

# Create subtask
bd create "Hash passwords" -p 2 --parent bd-a3f8.1
# Returns: bd-a3f8.1.1
```

### Stealth Mode

Use Beads without committing to main repo:

```bash
bd init --stealth
```

This creates `.beads/` in a separate branch that doesn't merge to main.

### Compaction

Summarize old closed tasks to save context:

```bash
bd compact
```

This uses AI to create semantic summaries of closed tasks, reducing context window usage.

## Best Practices

1. **Use Descriptive Titles**: Clear, specific task names
2. **Set Priorities**: P0 (critical) to P3 (nice-to-have)
3. **Track Dependencies**: Use `bd dep add` to show relationships
4. **Add Comments**: Document progress and decisions
5. **Close Promptly**: Mark tasks closed when done
6. **Compact Regularly**: Run `bd compact` to manage context

## Next Steps

- See `file-format.md` for JSONL structure
- See `manual-setup.md` for CLI-free setup
- See `best-practices.md` for advanced patterns

